<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你不懂JS：类型与文法 | You Don&#39;t Know JS （中文版）</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="《You Don't Know JS 》（中文版）">
    <link rel="preload" href="/js/assets/css/0.styles.7b8570ab.css" as="style"><link rel="preload" href="/js/assets/js/app.cc66767d.js" as="script"><link rel="preload" href="/js/assets/js/2.84f7ba8b.js" as="script"><link rel="preload" href="/js/assets/js/65.cd22986a.js" as="script"><link rel="prefetch" href="/js/assets/js/10.d557f331.js"><link rel="prefetch" href="/js/assets/js/11.00a88c6c.js"><link rel="prefetch" href="/js/assets/js/12.5e505089.js"><link rel="prefetch" href="/js/assets/js/13.82457747.js"><link rel="prefetch" href="/js/assets/js/14.58bc7df7.js"><link rel="prefetch" href="/js/assets/js/15.04ce4330.js"><link rel="prefetch" href="/js/assets/js/16.51582d93.js"><link rel="prefetch" href="/js/assets/js/17.2ecfafb1.js"><link rel="prefetch" href="/js/assets/js/18.d4c01a48.js"><link rel="prefetch" href="/js/assets/js/19.c70479b8.js"><link rel="prefetch" href="/js/assets/js/20.42aa3a6c.js"><link rel="prefetch" href="/js/assets/js/21.4680a991.js"><link rel="prefetch" href="/js/assets/js/22.9c5a2fd8.js"><link rel="prefetch" href="/js/assets/js/23.63073fb8.js"><link rel="prefetch" href="/js/assets/js/24.49bafe03.js"><link rel="prefetch" href="/js/assets/js/25.ceaf5843.js"><link rel="prefetch" href="/js/assets/js/26.23e84779.js"><link rel="prefetch" href="/js/assets/js/27.cb7930a8.js"><link rel="prefetch" href="/js/assets/js/28.6b68d414.js"><link rel="prefetch" href="/js/assets/js/29.681a0dc4.js"><link rel="prefetch" href="/js/assets/js/3.633b6153.js"><link rel="prefetch" href="/js/assets/js/30.a8405aff.js"><link rel="prefetch" href="/js/assets/js/31.0eced843.js"><link rel="prefetch" href="/js/assets/js/32.bb85c12a.js"><link rel="prefetch" href="/js/assets/js/33.006e5b77.js"><link rel="prefetch" href="/js/assets/js/34.1ca6bbe1.js"><link rel="prefetch" href="/js/assets/js/35.ce4b0384.js"><link rel="prefetch" href="/js/assets/js/36.08bc1b68.js"><link rel="prefetch" href="/js/assets/js/37.1d5a687e.js"><link rel="prefetch" href="/js/assets/js/38.9c61343b.js"><link rel="prefetch" href="/js/assets/js/39.b910f424.js"><link rel="prefetch" href="/js/assets/js/4.74c5cfb3.js"><link rel="prefetch" href="/js/assets/js/40.bf3c6413.js"><link rel="prefetch" href="/js/assets/js/41.289f6832.js"><link rel="prefetch" href="/js/assets/js/42.962170d5.js"><link rel="prefetch" href="/js/assets/js/43.dfe87c69.js"><link rel="prefetch" href="/js/assets/js/44.e39bc285.js"><link rel="prefetch" href="/js/assets/js/45.dd662169.js"><link rel="prefetch" href="/js/assets/js/46.e060ea59.js"><link rel="prefetch" href="/js/assets/js/47.0a830910.js"><link rel="prefetch" href="/js/assets/js/48.dd2b0b88.js"><link rel="prefetch" href="/js/assets/js/49.d3883d67.js"><link rel="prefetch" href="/js/assets/js/5.3c188138.js"><link rel="prefetch" href="/js/assets/js/50.d12e6fbf.js"><link rel="prefetch" href="/js/assets/js/51.5b2ce8bd.js"><link rel="prefetch" href="/js/assets/js/52.4ecade65.js"><link rel="prefetch" href="/js/assets/js/53.ba9063ae.js"><link rel="prefetch" href="/js/assets/js/54.84d62bec.js"><link rel="prefetch" href="/js/assets/js/55.37404ff2.js"><link rel="prefetch" href="/js/assets/js/56.3e9d0bf0.js"><link rel="prefetch" href="/js/assets/js/57.44b21305.js"><link rel="prefetch" href="/js/assets/js/58.219c6d2b.js"><link rel="prefetch" href="/js/assets/js/59.f5218bd9.js"><link rel="prefetch" href="/js/assets/js/6.31be9f49.js"><link rel="prefetch" href="/js/assets/js/60.82d213eb.js"><link rel="prefetch" href="/js/assets/js/61.85348caa.js"><link rel="prefetch" href="/js/assets/js/62.0c5d10a0.js"><link rel="prefetch" href="/js/assets/js/63.151c70ee.js"><link rel="prefetch" href="/js/assets/js/64.9d846cf1.js"><link rel="prefetch" href="/js/assets/js/66.cf634668.js"><link rel="prefetch" href="/js/assets/js/67.5125df54.js"><link rel="prefetch" href="/js/assets/js/68.97d018e3.js"><link rel="prefetch" href="/js/assets/js/69.9d966d36.js"><link rel="prefetch" href="/js/assets/js/7.f114a851.js"><link rel="prefetch" href="/js/assets/js/70.de473b2a.js"><link rel="prefetch" href="/js/assets/js/71.ae675192.js"><link rel="prefetch" href="/js/assets/js/72.4cd2a3aa.js"><link rel="prefetch" href="/js/assets/js/8.66159e32.js"><link rel="prefetch" href="/js/assets/js/9.a5d32e2a.js">
    <link rel="stylesheet" href="/js/assets/css/0.styles.7b8570ab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/js/" class="home-link router-link-active"><!----> <span class="site-name">You Don't Know JS （中文版）</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="推荐阅读" class="dropdown-title"><span class="title">推荐阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="推荐阅读" class="mobile-dropdown-title"><span class="title">推荐阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://roojay.com/es6tutorial/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  《ECMAScript 6 入门》
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://roojay.com/typescript/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  《TypeScript Handbook》（中文版）
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="推荐阅读" class="dropdown-title"><span class="title">推荐阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="推荐阅读" class="mobile-dropdown-title"><span class="title">推荐阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://roojay.com/es6tutorial/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  《ECMAScript 6 入门》
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://roojay.com/typescript/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  《TypeScript Handbook》（中文版）
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/js/up &amp; going/foreword.html" class="sidebar-link">序</a></li><li><a href="/js/preface.html" class="sidebar-link">前言</a></li><li><a href="/js/up &amp; going/apA.html" class="sidebar-link">鸣谢</a></li><li><section class="sidebar-group depth-0"><a href="/js/up &amp; going" class="sidebar-heading clickable"><span>入门与进阶</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/up &amp; going/ch1.html" class="sidebar-link">第一章：进入编程</a></li><li><a href="/js/up &amp; going/ch2.html" class="sidebar-link">第二章：进入JavaScript</a></li><li><a href="/js/up &amp; going/ch3.html" class="sidebar-link">第三章：进入YDKJS</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js/scope &amp; closures" class="sidebar-heading clickable"><span>作用域与闭包</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/scope &amp; closures/ch1.html" class="sidebar-link">第一章：什么是作用域？</a></li><li><a href="/js/scope &amp; closures/ch2.html" class="sidebar-link">第二章：词法作用域</a></li><li><a href="/js/scope &amp; closures/ch3.html" class="sidebar-link">第三章：函数与块儿作用域</a></li><li><a href="/js/scope &amp; closures/ch4.html" class="sidebar-link">第四章：提升</a></li><li><a href="/js/scope &amp; closures/ch5.html" class="sidebar-link">第五章：作用域闭包</a></li><li><a href="/js/scope &amp; closures/apA.html" class="sidebar-link">附录A：动态作用域</a></li><li><a href="/js/scope &amp; closures/apB.html" class="sidebar-link">附录B：填补块儿作用域</a></li><li><a href="/js/scope &amp; closures/apC.html" class="sidebar-link">附录C：词法 this</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js/this &amp; object prototypes" class="sidebar-heading clickable"><span>this与对象原型</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/this &amp; object prototypes/ch1.html" class="sidebar-link">第一章：this 是什么</a></li><li><a href="/js/this &amp; object prototypes/ch2.html" class="sidebar-link">第二章：this 豁然开朗</a></li><li><a href="/js/this &amp; object prototypes/ch3.html" class="sidebar-link">第三章：对象</a></li><li><a href="/js/this &amp; object prototypes/ch4.html" class="sidebar-link">第四章：混合（淆）“类”的对象</a></li><li><a href="/js/this &amp; object prototypes/ch5.html" class="sidebar-link">第五章：原型</a></li><li><a href="/js/this &amp; object prototypes/ch6.html" class="sidebar-link">第六章：行为委托</a></li><li><a href="/js/this &amp; object prototypes/apA.html" class="sidebar-link">附录A：ES6 class</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js/types &amp; grammar" class="sidebar-heading clickable open"><span>类型与文法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/types &amp; grammar/ch1.html" class="sidebar-link">第一章：类型</a></li><li><a href="/js/types &amp; grammar/ch2.html" class="sidebar-link">第二章：值</a></li><li><a href="/js/types &amp; grammar/ch3.html" class="active sidebar-link">第三章：原生类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/types &amp; grammar/ch3.html#内部-class" class="sidebar-link">内部 [[Class]]</a></li><li class="sidebar-sub-header"><a href="/js/types &amp; grammar/ch3.html#封箱包装器" class="sidebar-link">封箱包装器</a></li><li class="sidebar-sub-header"><a href="/js/types &amp; grammar/ch3.html#开箱" class="sidebar-link">开箱</a></li><li class="sidebar-sub-header"><a href="/js/types &amp; grammar/ch3.html#原生类型作为构造器" class="sidebar-link">原生类型作为构造器</a></li><li class="sidebar-sub-header"><a href="/js/types &amp; grammar/ch3.html#复习" class="sidebar-link">复习</a></li></ul></li><li><a href="/js/types &amp; grammar/ch4.html" class="sidebar-link">第四章：强制转换</a></li><li><a href="/js/types &amp; grammar/ch5.html" class="sidebar-link">第五章：文法</a></li><li><a href="/js/types &amp; grammar/apA.html" class="sidebar-link">附录A：与环境混合的 JavaScript</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js/async &amp; performance" class="sidebar-heading clickable"><span>异步与性能</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/async &amp; performance/ch1.html" class="sidebar-link">第一章: 异步:现在与稍后</a></li><li><a href="/js/async &amp; performance/ch2.html" class="sidebar-link">第二章：回调</a></li><li><a href="/js/async &amp; performance/ch3.html" class="sidebar-link">第三章：Promise</a></li><li><a href="/js/async &amp; performance/ch4.html" class="sidebar-link">第四章：Generator</a></li><li><a href="/js/async &amp; performance/ch5.html" class="sidebar-link">第五章：程序性能</a></li><li><a href="/js/async &amp; performance/ch6.html" class="sidebar-link">第六章：基准分析与调优</a></li><li><a href="/js/async &amp; performance/apA.html" class="sidebar-link">附录A：库：asynquence</a></li><li><a href="/js/async &amp; performance/apB.html" class="sidebar-link">附录B：高级异步模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js/es6 &amp; beyond" class="sidebar-heading clickable"><span>ES6与未来</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6 &amp; beyond/ch1.html" class="sidebar-link">第一章：ES？现在与未来</a></li><li><a href="/js/es6 &amp; beyond/ch2.html" class="sidebar-link">第二章：语法</a></li><li><a href="/js/es6 &amp; beyond/ch3.html" class="sidebar-link">第三章：组织</a></li><li><a href="/js/es6 &amp; beyond/ch4.html" class="sidebar-link">第四章：异步流程控制</a></li><li><a href="/js/es6 &amp; beyond/ch5.html" class="sidebar-link">第五章：集合</a></li><li><a href="/js/es6 &amp; beyond/ch6.html" class="sidebar-link">第六章：新增 API</a></li><li><a href="/js/es6 &amp; beyond/ch7.html" class="sidebar-link">第七章：元编程</a></li><li><a href="/js/es6 &amp; beyond/ch8.html" class="sidebar-link">第八章：ES6 之后</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="你不懂js-类型与文法"><a href="#你不懂js-类型与文法" class="header-anchor">#</a> 你不懂JS：类型与文法</h1> <h1 id="第三章-原生类型"><a href="#第三章-原生类型" class="header-anchor">#</a> 第三章：原生类型</h1> <p>在第一和第二章中，我们几次提到了各种内建类型，通常称为“原生类型”，比如 <code>String</code> 和 <code>Number</code>。现在让我们来仔细检视它们。</p> <p>这是最常用的原生类型的一览：</p> <ul><li><code>String()</code></li> <li><code>Number()</code></li> <li><code>Boolean()</code></li> <li><code>Array()</code></li> <li><code>Object()</code></li> <li><code>Function()</code></li> <li><code>RegExp()</code></li> <li><code>Date()</code></li> <li><code>Error()</code></li> <li><code>Symbol()</code> —— 在 ES6 中被加入的！</li></ul> <p>如你所见，这些原生类型实际上是内建函数。</p> <p>如果你拥有像 Java 语言那样的背景，JavaScript 的 <code>String()</code> 看起来像是你曾经用来创建字符串值的 <code>String(..)</code> 构造器。所以，你很快就会观察到你可以做这样的事情：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello World!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello World!&quot;</span>
</code></pre></div><p>这些原生类型的每一种确实可以被用作一个原生类型的构造器。但是被构建的东西可能与你想象的不同：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot; ... 不是 &quot;String&quot;</span>

a <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
</code></pre></div><p>创建值的构造器形式（<code>new String(&quot;abc&quot;)</code>）的结果是一个基本类型值（<code>&quot;abc&quot;</code>）的包装器对象。</p> <p>重要的是，<code>typeof</code> 显示这些对象不是它们自己的特殊 <em>类型</em>，而是 <code>object</code> 类型的子类型。</p> <p>这个包装器对象可以被进一步观察，像这样：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个语句的输出会根据你使用的浏览器变化，因为对于开发者的查看，开发者控制台可以自由选择它认为合适的方式来序列化对象。</p> <p><strong>注意：</strong> 在写作本书时，最新版的 Chrome 打印出这样的东西：<code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</code>。但是老版本的 Chrome 曾经只打印出这些：<code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code>。当前最新版的 Firefox 打印 <code>String [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>，但它曾经以斜体字打印 <code>&quot;abc&quot;</code>，点击它可以打开对象查看器。当然，这些结果是总频繁变更的，而且你的体验也许不同。</p> <p>重点是，<code>new String(&quot;abc&quot;)</code> 为 <code>&quot;abc&quot;</code> 创建了一个字符串包装器对象，而不仅是基本类型值 <code>&quot;abc&quot;</code> 本身。</p> <h2 id="内部-class"><a href="#内部-class" class="header-anchor">#</a> 内部 <code>[[Class]]</code></h2> <p><code>typeof</code> 的结果为 <code>&quot;object&quot;</code> 的值（比如数组）被额外地打上了一个内部的标签属性 <code>[[Class]]</code>（请把它考虑为一个内部的分类方法，而非与传统的面向对象编码的类有关）。这个属性不能直接地被访问，但通常可以间接地通过在这个值上借用默认的 <code>Object.prototype.toString(..)</code> 方法调用来展示。举例来说：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;[object Array]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token regex">/regex-literal/i</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;[object RegExp]&quot;</span>
</code></pre></div><p>所以，对于这个例子中的数组来说，内部的 <code>[[Class]]</code> 值是 <code>&quot;Array&quot;</code>，而对于正则表达式，它是 <code>&quot;RegExp&quot;</code>。在大多数情况下，这个内部的 <code>[[Class]]</code> 值对应于关联这个值的内建的原生类型构造器（见下面的讨论），但事实却不总是这样。</p> <p>基本类型呢？首先，<code>null</code> 和 <code>undefined</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;[object Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">undefined</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;[object Undefined]&quot;</span>
</code></pre></div><p>你会注意到，不存在 <code>Null()</code> 和 <code>Undefined()</code> 原生类型构造器，但不管怎样 <code>&quot;Null&quot;</code> 和 <code>&quot;Undefined&quot;</code> 是被暴露出来的内部 <code>[[Class]]</code> 值。</p> <p>但是对于像 <code>string</code>、<code>number</code>、和 <code>boolean</code> 这样的简单基本类型，实际上会启动另一种行为，通常称为“封箱（boxing）”（见下一节“封箱包装器”）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;[object Number]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token boolean">true</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;[object Boolean]&quot;</span>
</code></pre></div><p>在这个代码段中，每一个简单基本类型都自动地被它们分别对应的对象包装器封箱，这就是为什么 <code>&quot;String&quot;</code>、<code>&quot;Number&quot;</code>、和 <code>&quot;Boolean&quot;</code> 分别被显示为内部 <code>[[Class]]</code> 值。</p> <p><strong>注意：</strong> 从 ES5 发展到 ES6 的过程中，这里展示的 <code>toString()</code> 和 <code>[[Class]]</code> 的行为发生了一点儿改变，但我们会在本系列的 <em>ES6 与未来</em> 一书中讲解它们的细节。</p> <h2 id="封箱包装器"><a href="#封箱包装器" class="header-anchor">#</a> 封箱包装器</h2> <p>这些对象包装器服务于一个非常重要的目的。基本类型值没有属性或方法，所以为了访问 <code>.length</code> 或 <code>.toString()</code> 你需要这个值的对象包装器。值得庆幸的是，JS 将会自动地 <em>封箱</em>（也就是包装）基本类型值来满足这样的访问。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;ABC&quot;</span>
</code></pre></div><p>那么，如果你想以通常的方式访问这些字符串值上的属性/方法，比如一个 <code>for</code> 循环的 <code>i &lt; a.length</code> 条件，这么做看起来很有道理：一开始就得到一个这个值的对象形式，于是 JS 引擎就不需要隐含地为你创建一个。</p> <p>但事实证明这是一个坏主意。浏览器们长久以来就对 <code>.length</code> 这样的常见情况进行性能优化，这意味着如果你试着直接使用对象形式（它们没有被优化过）进行“提前优化”，那么实际上你的程序将会 <em>变慢</em>。</p> <p>一般来说，基本上没有理由直接使用对象形式。让封箱在需要的地方隐含地发生会更好。换句话说，永远也不要做 <code>new String(&quot;abc&quot;)</code>、<code>new Number(42)</code> 这样的事情 —— 应当总是偏向于使用基本类型字面量 <code>&quot;abc&quot;</code> 和 <code>42</code>。</p> <h3 id="对象包装器的坑"><a href="#对象包装器的坑" class="header-anchor">#</a> 对象包装器的坑</h3> <p>如果你 <em>确实</em> 选择要直接使用对象包装器，那么有几个坑你应该注意。</p> <p>举个例子，考虑 <code>Boolean</code> 包装的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span> <span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Oops&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 永远不会运行</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的问题是，虽然你为值 <code>false</code> 创建了一个对象包装器，但是对象本身是“truthy”（见第四章），所以使用对象的效果是与使用底层的值 <code>false</code> 本身相反的，这与通常的期望十分不同。</p> <p>如果你想手动封箱一个基本类型值，你可以使用 <code>Object(..)</code> 函数（没有 <code>new</code> 关键字）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> c<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>

b <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
</code></pre></div><p>再说一遍，通常不鼓励直接使用封箱的包装器对象（比如上面的 <code>b</code> 和 <code>c</code>），但你可能会遇到一些它们有用的罕见情况。</p> <h2 id="开箱"><a href="#开箱" class="header-anchor">#</a> 开箱</h2> <p>如果你有一个包装器对象，而你想要取出底层的基本类型值，你可以使用 <code>valueOf()</code> 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span> <span class="token boolean">true</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;abc&quot;</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
c<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>当以一种查询基本类型值的方式使用对象包装器时，开箱也会隐含地发生。这个处理的过程（强制转换）将会在第四章中更详细地讲解，但简单地说：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `b` 拥有开箱后的基本类型值&quot;abc&quot;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot;</span>
</code></pre></div><h2 id="原生类型作为构造器"><a href="#原生类型作为构造器" class="header-anchor">#</a> 原生类型作为构造器</h2> <p>对于 <code>array</code>、<code>object</code>、<code>function</code> 和正则表达式值来说，使用字面形式来创建它们的值几乎总是更好的选择，而且字面形式与构造器形式所创建的值是同一种对象（也就是，没有非包装的值）。</p> <p>正如我们刚刚在上面看到的其他原生类型，除非你真的知道你需要这些构造器形式，一般来说应当避免使用它们，这主要是因为它们会带来一些你可能不会想要对付的异常和陷阱。</p> <h3 id="array"><a href="#array" class="header-anchor">#</a> <code>Array(..)</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>
</code></pre></div><p><strong>注意：</strong> <code>Array(..)</code> 构造器不要求在它前面使用 <code>new</code> 关键字。如果你省略它，它也会像你已经使用了一样动作。所以 <code>Array(1,2,3)</code> 和 <code>new Array(1,2,3)</code> 的结果是一样的。</p> <p><code>Array</code> 构造器有一种特殊形式，如果它仅仅被传入一个 <code>number</code> 参数，与将这个值作为数组的 <em>内容</em> 不同，它会被认为是用来“预定数组大小”（嗯，某种意义上）用的长度。</p> <p>这是个可怕的主意。首先，你会意外地用错这种形式，因为它很容易忘记。</p> <p>但更重要的是，其实没有预定数组大小这样的东西。你所创建的是一个空数组，并将这个数组的 <code>length</code> 属性设置为那个指定的数字值。</p> <p>一个数组在它的值槽上没有明确的值，但是有一个 <code>length</code> 属性意味着这些值槽是存在的，在 JS 中这是一个诡异的数据结构，它带有一些非常奇怪且令人困惑的行为。可以创建这样的值的能力，完全源自于老旧的、已经废弃的、仅具有历史意义的功能（比如<code>arguments</code> 这样的“类数组对象”）。</p> <p><strong>注意：</strong> 带有至少一个“空值槽”的数组经常被称为“稀散数组”。</p> <p>这是另外一个例子，展示浏览器的开发者控制台在如何表示这样的对象上有所不同，它产生了更多的困惑。</p> <p>举例来说：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">;</span>
</code></pre></div><p>在 Chrome 中 <code>a</code> 的序列化表达是（在本书写作时）：<code>[ undefined x 3 ]</code>。<strong>这真的很不幸。</strong> 它暗示着在这个数组的值槽中有三个 <code>undefined</code> 值，而事实上这样的值槽是不存在的（所谓的“空值槽（empty slots）” —— 也是一个烂名字！）。</p> <p>要观察这种不同，试试这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>
</code></pre></div><p><strong>注意：</strong> 正如你在这个例子中看到的 <code>c</code>，数组中的空值槽可以在数组的创建之后发生。将数组的 <code>length</code> 改变为超过它实际定义的槽值的数目，你就隐含地引入了空值槽。事实上，你甚至可以在上面的代码段中调用 <code>delete b[1]</code>，而这么做将会在 <code>b</code> 的中间引入一个空值槽。</p> <p>对于 <code>b</code>（在当前的 Chrome 中），你会发现它的序列化表现为 <code>[ undefined, undefined, undefined ]</code>，与之相对的是 <code>a</code> 和 <code>c</code> 的 <code>[ undefined x 3 ]</code>。糊涂了吧？是的，大家都糊涂了。</p> <p>更糟糕的是，在写作本书时，Firefox 对 <code>a</code> 和 <code>c</code> 报告 <code>[ , , , ]</code>。你发现为什么这使人犯糊涂了吗？仔细看。三个逗号表示有四个值槽，不是我们期望的三个值槽。</p> <p><strong>什么！？</strong> Firefox 在它们的序列化表达的末尾放了一个额外的 <code>,</code>，因为在 ES5 中，列表（数组值，属性列表等等）末尾的逗号是允许的（被砍掉并忽略）。所以如果你在你的程序或控制台中敲入 <code>[ , , , ]</code> 值，你实际上得到的是一个底层为 <code>[ , , ]</code> 的值（也就是，一个带有三个空值槽的数组）。这种选择，虽然在阅读开发者控制台时使人困惑，但是因为它使拷贝粘贴的时候准确，所以被留了下来。</p> <p>如果你现在在摇头或翻白眼儿，你并不孤单！（耸肩）</p> <p>不幸的是，事情越来越糟。比在控制台的输出产生的困惑更糟的是，上面代码段中的 <code>a</code> 和 <code>b</code> 实际上在有些情况下相同，<strong>但在另一些情况下不同</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;-&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>
b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;-&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>

a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span>i</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ undefined x 3 ]</span>
b<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span>i</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ 0, 1, 2 ]</span>
</code></pre></div><p><strong>呃。</strong></p> <p><code>a.map(..)</code> 调用会 <em>失败</em> 是因为值槽根本就不实际存在，所以 <code>map(..)</code> 没有东西可以迭代。<code>join(..)</code> 的工作方式不同，基本上我们可以认为它是像这样被实现的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fakeJoin</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span>connector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			str <span class="token operator">+=</span> connector<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			str <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fakeJoin</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>
</code></pre></div><p>如你所见，<code>join(..)</code> 好用仅仅是因为它 <em>认为</em> 值槽存在，并循环至 <code>length</code> 值。不管 <code>map(..)</code> 内部是在做什么，它（显然）没有做出这样的假设，所以源自于奇怪的“空值槽”数组的结果出人意料，而且好像是失败了。</p> <p>那么，如果你想要 <em>确实</em> 创建一个实际的 <code>undefined</code> 值的数组（不只是“空值槽”），你如何才能做到呢（除了手动以外）？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> length<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [ undefined, undefined, undefined ]</span>
</code></pre></div><p>糊涂了吧？是的。这里是它大概的工作方式。</p> <p><code>apply(..)</code> 是一个对所有函数可用的工具方法，它以一种特殊方式调用这个使用它的函数。</p> <p>第一个参数是一个 <code>this</code> 对象绑定（在本系列的 <em>this 与对象原型</em> 中有详细讲解），在这里我们不关心它，所以我们将它设置为 <code>null</code>。第二个参数应该是一个数组（或 <em>像</em> 数组的东西 —— 也就是“类数组对象”）。这个“数组”的内容作为这个函数的参数“扩散”开来。</p> <p>所以，<code>Array.apply(..)</code> 在调用 <code>Array(..)</code> 函数，并将一个值（<code>{ length: 3 }</code> 对象值）作为它的参数值扩散开。</p> <p>在 <code>apply(..)</code> 内部，我们可以预见这里有另一个 <code>for</code> 循环（有些像上面的 <code>join(..)</code>），它从 <code>0</code> 开始上升但不包含至 <code>length</code>（这个例子中是 <code>3</code>）。</p> <p>对于每一个索引，它从对象中取得相应的键。所以如果这个数组对象参数在 <code>apply(..)</code> 内部被命名为 <code>arr</code>，那么这种属性访问实质上是<code>arr[0]</code>、<code>arr[1]</code> 和 <code>arr[2]</code>。当然，没有一个属性是在 <code>{ length: 3 }</code> 对象值上存在的，所以这三个属性访问都将返回值 <code>undefined</code>。</p> <p>换句话说，调用 <code>Array(..)</code> 的结局基本上是这样：<code>Array(undefined,undefined,undefined)</code>，这就是我们如何得到一个填满 <code>undefined</code> 值的数组的，而非仅仅是一些（疯狂的）空值槽。</p> <p>虽然对于创建一个填满 <code>undefined</code> 值的数组来说，<code>Array.apply( null, { length: 3 } )</code> 是一个奇怪而且繁冗的方法，但是它要比使用砸自己的脚似的 <code>Array(3)</code> 空值槽要可靠和好得 <strong>太多了</strong>。</p> <p>底线：你 <strong>在任何情况下，永远不</strong>，也不应该有意地创建并使用诡异的空值槽数组。就别这么干。它们是怪胎。</p> <h3 id="object-、function-和-regexp"><a href="#object-、function-和-regexp" class="header-anchor">#</a> <code>Object(..)</code>、<code>Function(..)</code> 和 <code>RegExp(..)</code></h3> <p><code>Object(..)</code>/<code>Function(..)</code>/<code>RegExp(..)</code> 构造器一般来说也是可选的（因此除非是特别的目的，应当避免使用）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
c<span class="token punctuation">;</span> <span class="token comment">// { foo: &quot;bar&quot; }</span>

<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
d<span class="token punctuation">;</span> <span class="token comment">// { foo: &quot;bar&quot; }</span>

<span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;return a * 2;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span> <span class="token string">&quot;^a*b+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;g&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token regex">/^a*b+/g</span><span class="token punctuation">;</span>
</code></pre></div><p>几乎没有理由使用 <code>new Object()</code> 构造器形式，尤其因为它强迫你一个一个地添加属性，而不是像对象的字面形式那样一次添加许多。</p> <p><code>Function</code> 构造器仅在最最罕见的情况下有用，也就是你需要动态地定义一个函数的参数和/或它的函数体。<strong>不要将 <code>Function(..)</code> 仅仅作为另一种形式的 <code>eval(..)</code></strong>。你几乎永远不会需要用这种方式动态定义一个函数。</p> <p>用字面量形式（<code>/^a*b+/g</code>）定义正则表达式是被大力采用的，不仅因为语法简单，而且还有性能的原因 —— JS 引擎会在代码执行前预编译并缓存它们。和我们迄今看到的其他构造器形式不同，<code>RegExp(..)</code> 有一些合理的用途：用来动态定义一个正则表达式的范例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Kyle&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> namePattern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span> <span class="token string">&quot;\\b(?:&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;)+\\b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ig&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> matches <span class="token operator">=</span> someText<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span> namePattern <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样的场景在 JS 程序中一次又一次地合法出现，所以你有需要使用 <code>new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</code> 形式。</p> <h3 id="date-和-error"><a href="#date-和-error" class="header-anchor">#</a> <code>Date(..)</code> 和 <code>Error(..)</code></h3> <p><code>Date(..)</code> 和 <code>Error(..)</code> 原生类型构造器要比其他种类的原生类型有用得多，因为它们没有字面量形式。</p> <p>要创建一个日期对象值，你必须使用 <code>new Date()</code>。<code>Date(..)</code> 构造器接收可选参数值来指定要使用的日期/时间，但是如果省略的话，就会使用当前的日期/时间。</p> <p>目前你构建一个日期对象的最常见的理由是要得到当前的时间戳（一个有符号整数，从1970年1月1日开始算起的毫秒数）。你可以在一个日期对象实例上调用 <code>getTime（)</code> 得到它。</p> <p>但是在 ES5 中，一个更简单的方法是调用定义为 <code>Date.now()</code> 的静态帮助函数。而且在前 ES5 中填补它很容易：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Date<span class="token punctuation">.</span>now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Date<span class="token punctuation">.</span><span class="token function-variable function">now</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：</strong> 如果你不带 <code>new</code> 调用 <code>Date()</code>，你将会得到一个那个时刻的日期/时间的字符串表达。在语言规范中没有规定这个表达的确切形式，虽然各个浏览器趋向于赞同使用这样的东西：<code>&quot;Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)&quot;</code>。</p> <p><code>Error(..)</code> 构造器（很像上面的 <code>Array()</code>）在有 <code>new</code> 与没有 <code>new</code> 时的行为是相同的。</p> <p>你想要创建 error 对象的主要原因是，它会将当前的执行栈上下文捕捉进对象中（在大多数 JS 引擎中，在创建后使用只读的 <code>.stack</code> 属性表示）。这个栈上下文包含函数调用栈和 error 对象被创建时的行号，这使调试这个错误更简单。</p> <p>典型地，你将与 <code>throw</code> 操作符一起使用这样的 error 对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span> <span class="token string">&quot;x wasn't provided&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Error 对象实例一般拥有至少一个 <code>message</code> 属性，有时还有其他属性（你应当将它们作为只读的），比如 <code>type</code>。然而，与其检视上面提到的 <code>stack</code> 属性，最好是在 error 对象上调用 <code>toString()</code>（明确地调用，或者是通过强制转换隐含地调用 —— 见第四章）来得到一个格式友好的错误消息。</p> <p><strong>提示：</strong> 技术上讲，除了一般的 <code>Error(..)</code> 原生类型以外，还有几种特定错误的原生类型：<code>EvalError(..)</code>、<code>RangeError(..)</code>、<code>ReferenceError(..)</code>、<code>SyntaxError(..)</code>、<code>TypeError(..)</code> 和 <code>URIError(..)</code>。但是手动使用这些特定错误原生类型十分少见。如果你的程序确实遭受了一个真实的异常，它们是会自动地被使用的（比如引用一个未声明的变量而得到一个 <code>ReferenceError</code> 错误）。</p> <h3 id="symbol"><a href="#symbol" class="header-anchor">#</a> <code>Symbol(..)</code></h3> <p>在 ES6 中，新增了一个基本值类型，称为“Symbol”。Symbol 是一种特殊的“独一无二”（不是严格保证的!）的值，可以作为对象上的属性使用而几乎不必担心任何冲突。它们主要是为特殊的 ES6 结构的内建行为设计的，但你也可以定义你自己的 symbol。</p> <p>Symbol 可以用做属性名，但是你不能从你的程序中看到或访问一个 symbol 的实际值，从开发者控制台也不行。例如，如果你在开发者控制台中对一个 Symbol 求值，将会显示 <code>Symbol(Symbol.create)</code> 之类的东西。</p> <p>在 ES6 中有几种预定义的 Symbol，做为 <code>Symbol</code> 函数对象的静态属性访问，比如 <code>Symbol.create</code>，<code>Symbol.iterator</code> 等等。要使用它们，可以这样做：</p> <div class="language-js extra-class"><pre class="language-js"><code>obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/*..*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>要定义你自己的 Symbol，使用 <code>Symbol(..)</code> 原生类型。<code>Symbol(..)</code> 原生类型“构造器”很独特，因为它不允许你将 <code>new</code> 与它一起使用，这么做会抛出一个错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> mysym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span> <span class="token string">&quot;my own symbol&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
mysym<span class="token punctuation">;</span>				<span class="token comment">// Symbol(my own symbol)</span>
mysym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;Symbol(my own symbol)&quot;</span>
<span class="token keyword">typeof</span> mysym<span class="token punctuation">;</span> 		<span class="token comment">// &quot;symbol&quot;</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mysym<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;foobar&quot;</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [ Symbol(my own symbol) ]</span>
</code></pre></div><p>虽然 Symbol 实际上不是私有的（在对象上使用 <code>Object.getOwnPropertySymbols(..)</code> 反射，揭示了 Symbol 其实是相当公开的），但是它们的主要用途可能是私有属性，或者类似的特殊属性。对于大多数开发者，他们也许会在属性名上加入 <code>_</code> 下划线前缀，这在经常在惯例上表示：“这是一个私有的/特殊的/内部的属性，别碰！”</p> <p><strong>注意：</strong> <code>Symbol</code> <em>不是</em> <code>object</code>，它们是简单的基本标量。</p> <h3 id="原生类型原型"><a href="#原生类型原型" class="header-anchor">#</a> 原生类型原型</h3> <p>每一个内建的原生构造器都拥有它自己的 <code>.prototype</code> 对象 —— <code>Array.prototype</code>，<code>String.prototype</code> 等等。</p> <p>对于它们特定的对象子类型，这些对象含有独特的行为。</p> <p>例如，所有的字符串对象，和 <code>string</code> 基本值的扩展（通过封箱），都可以访问在 <code>String.prototype</code> 对象上做为方法定义的默认行为。</p> <p><strong>注意：</strong> 做为文档惯例，<code>String.prototype.XYZ</code> 会被缩写为 <code>String#XYZ</code>，对于其它所有 <code>.prototype</code> 的属性都是如此。</p> <ul><li><code>String#indexOf(..)</code>：在一个字符串中找出一个子串的位置</li> <li><code>String#charAt(..)</code>：访问一个字符串中某个位置的字符</li> <li><code>String#substr(..)</code>、<code>String#substring(..)</code> 和 <code>String#slice(..)</code>：将字符串的一部分抽取为一个新字符串</li> <li><code>String#toUpperCase()</code> 和 <code>String#toLowerCase()</code>：创建一个转换为大写或小写的新字符串</li> <li><code>String#trim()</code>：创建一个截去开头或结尾空格的新字符串。</li></ul> <p>这些方法中没有一个是在 <em>原地</em> 修改字符串的。修改（比如大小写变换或去空格）会根据当前的值来创建一个新的值。</p> <p>有赖于原型委托（见本系列的 <em>this 与对象原型</em>），任何字符串值都可以访问这些方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot; abc &quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span> <span class="token string">&quot;c&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot; ABC &quot;</span>
a<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;abc&quot;</span>
</code></pre></div><p>其他构造器的原型包含适用于它们类型的行为，比如 <code>Number#toFixed(..)</code>（将一个数字转换为一个固定小数位的字符串）和 <code>Array#concat(..)</code>（混合数组）。所有这些函数都可以访问 <code>apply(..)</code>、<code>call(..)</code> 和 <code>bind(..)</code>，因为 <code>Function.prototype</code> 定义了它们。</p> <p>但是，一些原生类型的原型不 <em>仅仅</em> 是单纯的对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>			<span class="token comment">// &quot;function&quot;</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 它是一个空函数！</span>

<span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;/(?:)/&quot; —— 空的正则表达式</span>
<span class="token string">&quot;abc&quot;</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span> <span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// [&quot;&quot;]</span>
</code></pre></div><p>一个特别差劲儿的主意是，你甚至可以修改这些原生类型的原型（不仅仅是你可能熟悉的添加属性）：</p> <div class="language-js extra-class"><pre class="language-js"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 3</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>					<span class="token comment">// [1,2,3]</span>

<span class="token comment">// 别这么留着它，要不就等着怪事发生吧！</span>
<span class="token comment">// 将`Array.prototype`重置为空</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>如你所见，<code>Function.prototype</code> 是一个函数，<code>RegExp.prototype</code> 是一个正则表达式，而 <code>Array.prototype</code> 是一个数组。有趣吧？酷吧？</p> <h4 id="原型作为默认值"><a href="#原型作为默认值" class="header-anchor">#</a> 原型作为默认值</h4> <p><code>Function.prototype</code> 是一个空函数，<code>RegExp.prototype</code> 是一个“空”正则表达式（也就是不匹配任何东西），而 <code>Array.prototype</code> 是一个空数组，这使它们成了可以赋值给变量的，很好的“默认”值 —— 如果这些类型的变量还没有值。</p> <p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token parameter">vals<span class="token punctuation">,</span>fn<span class="token punctuation">,</span>rx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vals <span class="token operator">=</span> vals <span class="token operator">||</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
	fn <span class="token operator">=</span> fn <span class="token operator">||</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
	rx <span class="token operator">=</span> rx <span class="token operator">||</span> <span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

	<span class="token keyword">return</span> rx<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>
		vals<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> fn <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span>
	<span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token regex">/D/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// false</span>
</code></pre></div><p><strong>注意：</strong> 在 ES6 中，我们不再需要使用 <code>vals = vals || ..</code> 这样的默认值语法技巧了（见第四章），因为在函数声明中可以通过原生语法为参数设定默认值（见第五章）。</p> <p>这个方式的一个微小的副作用是，<code>.prototype</code> 已经被创建了，而且是内建的，因此它仅被创建 <em>一次</em>。相比之下，使用 <code>[]</code>、<code>function(){}</code> 和 <code>/(?:)/</code> 这些值本身作为默认值，将会（很可能，要看引擎如何实现）在每次调用 <code>isThisCool(..)</code> 时重新创建这些值（而且稍可能要回收它们）。这可能会消耗内存/CPU。</p> <p>另外，要非常小心不要对 <strong>后续要被修改的值</strong> 使用 <code>Array.prototype</code> 做为默认值。在这个例子中，<code>vals</code> 是只读的，但如果你要在原地对 <code>vals</code> 进行修改，那你实际上修改的是 <code>Array.prototype</code> 本身，这将把你引到刚才提到的坑里！</p> <p><strong>注意：</strong> 虽然我们指出了这些原生类型的原型和一些用处，但是依赖它们的时候要小心，更要小心以任何形式修改它们。更多的讨论见附录A“原生原型”。</p> <h2 id="复习"><a href="#复习" class="header-anchor">#</a> 复习</h2> <p>JavaScript 为基本类型提供了对象包装器，被称为原生类型（<code>String</code>、<code>Number</code>、<code>Boolean</code> 等等）。这些对象包装器使这些值可以访问每种对象子类型的恰当行为（<code>String#trim()</code> 和 <code>Array#concat(..)</code>）。</p> <p>如果你有一个像 <code>&quot;abc&quot;</code> 这样的简单基本类型标量，而且你想要访问它的 <code>length</code> 属性或某些 <code>String.prototype</code> 方法，JS 会自动地“封箱”这个值（用它所对应种类的对象包装器把它包起来），以满足这样的属性/方法访问。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/11/2020, 3:27:53 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/types &amp; grammar/ch2.html" class="prev">
        第二章：值
      </a></span> <span class="next"><a href="/js/types &amp; grammar/ch4.html">
        第四章：强制转换
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/js/assets/js/app.cc66767d.js" defer></script><script src="/js/assets/js/2.84f7ba8b.js" defer></script><script src="/js/assets/js/65.cd22986a.js" defer></script>
  </body>
</html>
